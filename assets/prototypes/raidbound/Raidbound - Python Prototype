import tkinter as tk
from dataclasses import dataclass
import random
import time

# -----------------------------
# Helpers / Data
# -----------------------------
def clamp(v, lo, hi):
    return max(lo, min(hi, v))

@dataclass
class Unit:
    name: str
    max_hp: int
    hp: float
    armor: float = 0.0
    max_mana: int = 0
    mana: float = 0.0
    mana_regen: float = 0.0

    def is_alive(self):
        return self.hp > 0

@dataclass
class Boss:
    name: str
    max_hp: int
    hp: float
    armor: float = 0.0

    def is_alive(self):
        return self.hp > 0

@dataclass
class Encounter:
    name: str
    max_hp: int
    armor: float
    tank_base_damage: float
    tank_charge_bonus: float
    tank_frenzy_bonus: float
    howl_enabled: bool
    howl_duration: float
    howl_slow_mult: float

@dataclass
class RunItem:
    name: str
    tag: str
    desc: str
    tank_hp: int = 0
    tank_armor: int = 0
    cleric_regen: float = 0.0
    raid_dps: float = 0.0
    wizard_damage: float = 0.0

LESSER_ITEMS = [
    RunItem("Patchwork Padding", "Tank", "+2 Tank HP", tank_hp=2),
    RunItem("Bent Buckler", "Tank", "+1 Tank Armor", tank_armor=1),
    RunItem("Qeynos Bandage", "Tank", "+3 Tank HP", tank_hp=3),

    RunItem("Prayer Beads (Run)", "Support", "+0.10 Cleric mana regen/sec", cleric_regen=0.10),
    RunItem("Blessed Candle", "Support", "+0.08 Cleric mana regen/sec", cleric_regen=0.08),
    RunItem("Silver Symbol", "Support", "+0.10 Cleric mana regen/sec", cleric_regen=0.10),

    RunItem("Sharpening Stone", "Melee", "+0.25 raid DPS", raid_dps=0.25),
    RunItem("Oil of Quickness", "Melee", "+0.30 raid DPS", raid_dps=0.30),
    RunItem("Lucky Coin", "Melee", "+0.25 raid DPS", raid_dps=0.25),

    RunItem("Cracked Focus Stone", "Ranged", "+0.5 Wizard damage", wizard_damage=0.5),
    RunItem("Rune Etching", "Ranged", "+0.5 Wizard damage", wizard_damage=0.5),
    RunItem("Dusty Grimoire Page", "Ranged", "+0.4 Wizard damage", wizard_damage=0.4),
]

QUEST_BONUS_ITEMS = [
    # Quest bonuses are intentionally modest but feel meaningful because they are delayed until the boss.
    RunItem("Orc Fang Earring", "Any", "+1 STR (flavor) +2 Tank HP", tank_hp=2),
    RunItem("Woven Grass Charm", "Tank", "+4 Tank HP", tank_hp=4),
    RunItem("Polished Bronze Shield", "Tank", "+1 Tank Armor", tank_armor=1),
    RunItem("Symbol of Faith", "Support", "+0.15 Cleric mana regen/sec", cleric_regen=0.15),
    RunItem("Battle Hymn Scroll", "Melee", "+0.45 raid DPS", raid_dps=0.45),
    RunItem("Spellshard Fragment", "Ranged", "+0.8 Wizard damage", wizard_damage=0.8),
]



@dataclass
class MapNode:
    depth: int                 # 1..15 (1=bottom, 15=boss)
    lane: int                  # 0..6 (horizontal position)
    kind: str                  # "SKIRMISH" | "ELITE" | "QUEST" | "BOSS"
    label: str                 # UI label
    encounter: Encounter | None = None
    quest_item: str | None = None

class RunState:
    def __init__(self):
        # Campaign-level state
        self.act = 1
        self.max_act = 3
        self.start_time = time.time()  # total run time across acts
        self.run_items: list[RunItem] = []
        self.reset_act()

    def reset_campaign(self):
        self.act = 1
        self.start_time = time.time()
        self.run_items = []
        self.reset_act()

    def reset_act(self):
        # Act-level state
        self.depth = 1
        self.current_pos: tuple[int, int] | None = None
        self.quest_item: str | None = None
        self.bonus_reward_item: RunItem | None = None
        self.path_taken: list[str] = []

    def run_seconds(self) -> int:
        return int(time.time() - self.start_time)

    def bonuses(self):
        tank_hp = sum(i.tank_hp for i in self.run_items)
        tank_armor = sum(i.tank_armor for i in self.run_items)
        cleric_regen = sum(i.cleric_regen for i in self.run_items)
        raid_dps = sum(i.raid_dps for i in self.run_items)
        wiz_dmg = sum(i.wizard_damage for i in self.run_items)
        return tank_hp, tank_armor, cleric_regen, raid_dps, wiz_dmg


# -----------------------------
# Encounters / Items
# -----------------------------
ACT_NAMES = {
    1: "Qeynos Hills",
    2: "Greater Faydark",
    3: "Najena's Dungeon",
}

def make_encounters(act: int):
    # Act 1: Gnolls / Fippy (fast pressure + disruption)
    if act == 1:
        return {
            "skirmish_a": Encounter("Gnoll Skirmishers", 220, 0, 10.1, 2.2, 1.3, True, 4.0, 0.78),
            "skirmish_b": Encounter("Hill Howlers", 240, 0, 10.3, 2.2, 1.5, True, 5.0, 0.72),
            "skirmish_c": Encounter("Brightwood Ambush", 250, 0, 10.2, 2.4, 1.5, False, 0.0, 1.0),
            "elite_a":    Encounter("Pack Leader", 300, 1, 10.8, 2.7, 1.8, True, 5.0, 0.72),
            "elite_b":    Encounter("Shaman & Guards", 330, 1, 11.1, 2.9, 2.0, True, 5.0, 0.70),
            "boss":       Encounter("Fippy Darkpaw", 440, 1, 10.1, 3.3, 2.4, True, 5.0, 0.70),
        }

    # Act 2: Orcs / Emperor Crush (heavier hits, more armor)
    if act == 2:
        return {
            "skirmish_a": Encounter("Orc Raiders", 260, 1, 11.1, 2.6, 1.7, False, 0.0, 1.0),
            "skirmish_b": Encounter("Crushbone Patrol", 270, 1, 11.3, 2.6, 1.8, True, 4.0, 0.80),
            "skirmish_c": Encounter("Scout Ambush", 280, 1, 11.2, 2.7, 1.8, False, 0.0, 1.0),
            "elite_a":    Encounter("Legionnaire Captain", 340, 2, 11.8, 3.1, 2.2, True, 5.0, 0.78),
            "elite_b":    Encounter("Orc Taskmaster", 360, 2, 12.1, 3.2, 2.4, True, 5.0, 0.76),
            "boss":       Encounter("Emperor Crush", 520, 2, 11.6, 3.5, 2.8, True, 6.0, 0.76),
        }

    # Act 3: Elementals & Ogres / Najena (high magic pressure, traps)
    # We reuse the existing "howl" mechanic as "Arcane Traps" that slow raid output.
    return {
        "skirmish_a": Encounter("Elemental Harriers", 300, 2, 12.0, 2.8, 1.9, True, 4.5, 0.78),
        "skirmish_b": Encounter("Maddened Ogres", 320, 2, 12.2, 2.9, 2.0, False, 0.0, 1.0),
        "skirmish_c": Encounter("Trap Hallway", 310, 2, 12.1, 3.0, 2.1, True, 5.0, 0.74),
        "elite_a":    Encounter("Arcane Warden", 380, 3, 12.6, 3.2, 2.4, True, 5.5, 0.72),
        "elite_b":    Encounter("Ogre Enforcer", 400, 3, 12.8, 3.3, 2.6, False, 0.0, 1.0),
        "boss":       Encounter("Najena", 620, 3, 12.4, 3.8, 3.0, True, 6.0, 0.70),
    }


QUEST_ITEMS_BY_ACT = {
    1: ["Gnoll Fang Necklace", "Qeynos Guard Seal", "Tattered Gnoll Map"],
    2: ["Orc Pawn Pick", "Crushbone Signet", "Elf Scout Report"],

    3: ["Elemental Core", "Najena's Key Fragment", "Burnt Spell Scroll"],
}


def pick_three(rng: random.Random, pool: list[RunItem]) -> list[RunItem]:
    return rng.sample(pool, 3)


# -----------------------------
# Map Generator (Slay-the-Spire style)
# -----------------------------
def generate_map(rng: random.Random, encounters: dict, quest_items: list[str]):
    """Generate a Slay-the-Spire style full-act map (left-to-right).

    Design goals (per latest iteration):
    - 15 steps total (depths 1..15), boss at 15.
    - 3 rows (lanes 0..2). Player traverses left->right.
    - Movement: right-up, right, right-down (i.e., lane change at most 1 per step).
    - Single starting node at (depth=1, lane=1).
    - Exactly 3 ELITE nodes total (never mandatory; always bypassable).
    - Exactly 1 QUEST node total, placed as a direct tradeoff against an elite (elite vs quest).
    - Node density kept modest (usually 1-2 nodes per step; sometimes 3).
    """
    DEPTHS = 15
    LANES = 3

    # --- Build lane layout per depth (excluding boss)
    layers: list[list[MapNode]] = []

    # Depth 1: single starting point in the middle row
    layers.append([MapNode(depth=1, lane=1, kind="SKIRMISH", label="Skirmish")])

    # Depths 2..14: usually 1-2 nodes, sometimes 3
    for d in range(2, DEPTHS):
        # keep icon count lower: bias toward 1-2 nodes
        count = rng.choices([1, 2, 3], weights=[0.35, 0.50, 0.15])[0]
        lanes = sorted(rng.sample(range(LANES), count))
        layers.append([MapNode(depth=d, lane=ln, kind="SKIRMISH", label="Skirmish") for ln in lanes])

    # Boss layer (depth 15) in middle row
    layers.append([MapNode(depth=DEPTHS, lane=1, kind="BOSS", label="Boss", encounter=encounters["boss"])])

    # --- Connect nodes between depths (only to same/adjacent row)
    edges: dict[tuple[int, int], list[tuple[int, int]]] = {}
    incoming: dict[tuple[int, int], int] = {}

    def add_edge(a, b):
        edges.setdefault(a, [])
        if b not in edges[a]:
            edges[a].append(b)
            incoming[b] = incoming.get(b, 0) + 1

    for d in range(1, DEPTHS):
        cur = layers[d - 1]
        nxt = layers[d]  # depth d+1
        nxt_lanes = [n.lane for n in nxt]

        for n in cur:
            a = (n.depth, n.lane)
            # candidates: right-up, right, right-down
            cand = [ln for ln in nxt_lanes if abs(ln - n.lane) <= 1]
            if not cand:
                cand = list(nxt_lanes)

            rng.shuffle(cand)
            # Usually 1 outgoing, sometimes 2 to preserve rogue-like branching
            picks = cand[:1]
            if len(cand) > 1 and rng.random() < 0.40:
                picks = cand[:2]

            for ln in picks:
                add_edge(a, (n.depth + 1, ln))

        # ensure every next node has at least one incoming edge
        prev_lanes = [n.lane for n in cur]
        for n in nxt:
            b = (n.depth, n.lane)
            if incoming.get(b, 0) > 0:
                continue
            # connect from closest previous lane (within 1 if possible)
            close = [pl for pl in prev_lanes if abs(pl - n.lane) <= 1]
            src_lane = rng.choice(close) if close else min(prev_lanes, key=lambda pl: abs(pl - n.lane))
            add_edge((d, src_lane), b)

    # --- Choose special nodes (with bypass guarantee)
    # Only place elites/quest on depths that have >=2 nodes so player can route around them.
    candidate_depths = [d for d in range(2, DEPTHS - 1) if len(layers[d - 1]) >= 2]  # avoid depth 1 and pre-boss
    if len(candidate_depths) < 4:
        # If RNG produced too many single-node layers, force-add a second node to a few depths
        for d in range(2, DEPTHS - 1):
            if len(layers[d - 1]) == 1:
                existing_lane = layers[d - 1][0].lane
                other_lanes = [ln for ln in range(LANES) if ln != existing_lane]
                if other_lanes:
                    layers[d - 1].append(MapNode(depth=d, lane=rng.choice(other_lanes), kind="SKIRMISH", label="Skirmish"))
                if len([dd for dd in range(2, DEPTHS - 1) if len(layers[dd - 1]) >= 2]) >= 4:
                    break
        candidate_depths = [d for d in range(2, DEPTHS - 1) if len(layers[d - 1]) >= 2]

    # Exactly 3 ELITE nodes total.
    # 35% chance: 2 elites on one depth + 1 elite elsewhere (enables "two elites" choice).
    if rng.random() < 0.35 and any(len(layers[d - 1]) >= 3 for d in candidate_depths):
        duo_candidates = [d for d in candidate_depths if len(layers[d - 1]) >= 3]
        duo_depth = rng.choice(duo_candidates)
        single_depth = rng.choice([dd for dd in candidate_depths if dd != duo_depth])
        elite_plan = {duo_depth: 2, single_depth: 1}
        quest_depth = duo_depth  # quest competes on the high-risk step
    else:
        depths = rng.sample(candidate_depths, 3)
        elite_plan = {dd: 1 for dd in depths}
        quest_depth = rng.choice(depths)

    # Place QUEST node (one total) on the same depth as an elite, but never overwrite the elite bypass node.
    q_layer = layers[quest_depth - 1]
    # choose a node that will NOT be elite if possible (we'll place elites after)
    q_node = rng.choice(q_layer)
    q_node.kind = "QUEST"
    q_node.label = "Quest"
    q_node.quest_item = rng.choice(quest_items)

    # Place ELITE nodes according to plan (never overwrite QUEST)
    for dd, cnt in elite_plan.items():
        layer = layers[dd - 1]
        candidates = [n for n in layer if n.kind == "SKIRMISH"]
        rng.shuffle(candidates)
        for n in candidates[:cnt]:
            n.kind = "ELITE"
            n.label = "Elite"

        # Bypass guarantee: ensure there is at least one non-elite option on this depth
        if not any(n.kind == "SKIRMISH" for n in layer):
            # If we accidentally converted everything (possible on 2-node layer where quest already used),
            # revert one elite back to skirmish.
            for n in layer:
                if n.kind == "ELITE":
                    n.kind = "SKIRMISH"
                    n.label = "Skirmish"
                    n.encounter = None
                    break

    # Ensure quest depth offers a real tradeoff: must have at least one ELITE and at least one non-quest alternative
    q_layer = layers[quest_depth - 1]
    if not any(n.kind == "ELITE" for n in q_layer):
        # promote one skirmish to elite (not the quest)
        sk = [n for n in q_layer if n.kind == "SKIRMISH"]
        if sk:
            n = rng.choice(sk)
            n.kind = "ELITE"
            n.label = "Elite"
    if not any(n.kind in ("SKIRMISH", "ELITE") for n in q_layer if n.kind != "QUEST"):
        # add a bypass skirmish node on an unused lane
        used = {n.lane for n in q_layer}
        open_lanes = [ln for ln in range(LANES) if ln not in used]
        if open_lanes:
            q_layer.append(MapNode(depth=quest_depth, lane=rng.choice(open_lanes), kind="SKIRMISH", label="Skirmish"))

    # --- Assign encounters (avoid duplicates within a depth)
    skirm_pool = [encounters["skirmish_a"], encounters["skirmish_b"], encounters["skirmish_c"]]
    elite_pool = [encounters["elite_a"], encounters["elite_b"]]

    for layer in layers:
        used_sk = set()
        used_el = set()
        for n in layer:
            if n.kind == "SKIRMISH":
                rng.shuffle(skirm_pool)
                pick = next((e for e in skirm_pool if e.name not in used_sk), None) or rng.choice(skirm_pool)
                n.encounter = pick
                used_sk.add(pick.name)
            elif n.kind == "ELITE":
                rng.shuffle(elite_pool)
                pick = next((e for e in elite_pool if e.name not in used_el), None) or rng.choice(elite_pool)
                n.encounter = pick
                used_el.add(pick.name)
            # QUEST already has quest_item; BOSS already has encounter

    return layers, edges
# -----------------------------
# Combat Simulation (Manager Mode + Levers)
# -----------------------------
class RaidFight:
    def __init__(self, run_state: RunState, node: MapNode):
        self.run_state = run_state
        self.node = node
        self.encounter = node.encounter
        self.reset()

    def reset(self):
        tank_hp_bonus, tank_armor_bonus, cleric_regen_bonus, raid_dps_bonus, wiz_dmg_bonus = self.run_state.bonuses()

        self.tank = Unit("Warrior (Tank)", max_hp=140 + tank_hp_bonus,
                         hp=140 + tank_hp_bonus, armor=3 + tank_armor_bonus)
        self.cleric = Unit("Cleric (Support)", max_hp=70, hp=70,
                           max_mana=70, mana=70, mana_regen=0.85 + cleric_regen_bonus)
        self.rogue = Unit("Rogue (Melee)", max_hp=80, hp=80, armor=1)
        self.wizard = Unit("Wizard (Ranged)", max_hp=50, hp=50,
                           max_mana=60, mana=60, mana_regen=0.4)

        self.boss = Boss(self.encounter.name, max_hp=self.encounter.max_hp, hp=self.encounter.max_hp, armor=self.encounter.armor)

        self.t = 0.0
        self.dt = 0.25

        self.heal_policy = "BALANCED"
        self.wiz_policy = "NORMAL"

        self.cleric_casting = False
        self.cleric_cast_remaining = 0.0
        self.cleric_cast_spell = None
        self.clutch_used = False

        self.rogue_backstab_timer = 5.0
        self.raid_dps_bonus = raid_dps_bonus

        self.wiz_damage_bonus = wiz_dmg_bonus
        self.wiz_casting = False
        self.wiz_cast_remaining = 0.0
        self.wiz_chain = 0
        self.wiz_backlash_remaining = 0.0

        self.howl_active_remaining = 0.0
        self.howl_timer = 14.0
        self.howl_cooldown = 14.0

        # levers
        self.tank_deflect_remaining = 0.0
        self.tank_deflect_cd = 0.0
        self.tank_taunt_remaining = 0.0
        self.tank_taunt_cd = 0.0
        self.rogue_burst_remaining = 0.0
        self.rogue_burst_cd = 0.0

        # Boss "aftershock" so cooldowns create rhythm instead of free safety.
        self.pending_deflect_rage = False
        self.rage_remaining = 0.0

        self.result = None
        self.last_event = f"{self.encounter.name} engaged."

    def phase(self):
        if self.boss.hp / self.boss.max_hp <= 0.30:
            return "FRENZY"
        if self.t < 12.0:
            return "CHARGE"
        return "HOWL" if self.encounter.howl_enabled else "STANDARD"

    def dps_multiplier(self):
        return self.encounter.howl_slow_mult if self.howl_active_remaining > 0 else 1.0

    def tank_damage_in(self):
        base = self.encounter.tank_base_damage
        ph = self.phase()
        if ph == "CHARGE":
            base += self.encounter.tank_charge_bonus
        if ph == "FRENZY":
            base += self.encounter.tank_frenzy_bonus

        # After Deflect ends, the boss "answers" for a couple seconds.
        if self.rage_remaining > 0:
            base *= 1.35

        return max(0.0, base)

    def update_howl(self):
        if not self.encounter.howl_enabled:
            return
        if self.howl_active_remaining > 0:
            self.howl_active_remaining = max(0.0, self.howl_active_remaining - self.dt)
        self.howl_timer -= self.dt
        if self.howl_timer <= 0 and self.phase() != "CHARGE":
            self.howl_active_remaining = self.encounter.howl_duration
            self.howl_timer = self.howl_cooldown
            self.last_event = f"{self.encounter.name} disrupts the raid! DPS slowed."

    # ----- Levers
    def tank_deflect(self):
        if self.tank_deflect_cd > 0 or self.result is not None:
            return
        self.tank_deflect_remaining = 1.3
        self.tank_deflect_cd = 18.0
        self.pending_deflect_rage = True
        self.last_event = "Tank DEFLECT! (Boss will answer after)"

    def tank_taunt(self):
        """Force the boss to target the tank for a short window."""
        if self.tank_taunt_cd > 0 or self.result is not None:
            return
        self.tank_taunt_remaining = 3.0
        self.tank_taunt_cd = 16.0
        self.last_event = "Tank TAUNT! (Aggro back on tank)"

    def rogue_backstab(self):
        if self.rogue_burst_cd > 0 or self.result is not None:
            return
        # Backstab: burst damage + briefly pulls aggro.
        self.rogue_burst_remaining = 2.4
        self.rogue_burst_cd = 12.0
        self.last_event = "Rogue BACKSTAB! (Burst damage, pulls aggro)"

    # ----- Cleric
    def cleric_tick(self):
        self.cleric.mana = clamp(self.cleric.mana + self.cleric.mana_regen * self.dt, 0, self.cleric.max_mana)

        if self.cleric_casting:
            self.cleric_cast_remaining -= self.dt
            if self.cleric_cast_remaining <= 0:
                if self.cleric_cast_spell == "fast":
                    self.tank.hp = clamp(self.tank.hp + 6, 0, self.tank.max_hp)
                    self.last_event = "Cleric Fast Heal (+6)."
                else:
                    self.tank.hp = clamp(self.tank.hp + 12, 0, self.tank.max_hp)
                    self.last_event = "Cleric Greater Heal (+12)."
                self.cleric_casting = False
                self.cleric_cast_spell = None
            return

        if (not self.clutch_used) and (self.tank.hp / self.tank.max_hp <= 0.20):
            self.clutch_used = True
            self.tank.hp = clamp(self.tank.hp + 14, 0, self.tank.max_hp)
            self.last_event = "Cleric clutch heal triggers (+14)."
            return

        missing = self.tank.max_hp - self.tank.hp

        if self.heal_policy == "PANIC":
            fast_threshold = 5
            greater_threshold = 12
            fast_cast = 0.85
            greater_cast = 1.75
        elif self.heal_policy == "CONSERVE":
            fast_threshold = 9
            greater_threshold = 20
            fast_cast = 1.1
            greater_cast = 2.1
        else:
            fast_threshold = 7
            greater_threshold = 15
            fast_cast = 1.0
            greater_cast = 2.0

        if missing >= greater_threshold and self.cleric.mana >= 6:
            self.cleric.mana -= 6
            self.cleric_casting = True
            self.cleric_cast_remaining = greater_cast
            self.cleric_cast_spell = "greater"
            return

        if missing >= fast_threshold and self.cleric.mana >= 3:
            self.cleric.mana -= 3
            self.cleric_casting = True
            self.cleric_cast_remaining = fast_cast
            self.cleric_cast_spell = "fast"
            return

    # ----- Rogue
    def rogue_tick(self):
        mult = self.dps_multiplier()
        burst_mult = 3.0 if self.rogue_burst_remaining > 0 else 1.0

        base = (5.1 + self.raid_dps_bonus) * mult * self.dt
        self.boss.hp = max(0.0, self.boss.hp - (base * burst_mult))

        self.rogue_backstab_timer -= self.dt
        if self.rogue_backstab_timer <= 0:
            self.rogue_backstab_timer = 5.0
            backstab = (6.0 * mult) * burst_mult
            self.boss.hp = max(0.0, self.boss.hp - backstab)
            self.last_event = f"Rogue backstabs (-{int(backstab)} Boss HP)."

    # ----- Wizard
    def wizard_tick(self):
        self.wizard.mana = clamp(self.wizard.mana + self.wizard.mana_regen * self.dt, 0, self.wizard.max_mana)

        if self.wiz_backlash_remaining > 0:
            self.wiz_backlash_remaining = max(0.0, self.wiz_backlash_remaining - self.dt)
            self.wizard.hp = max(0.0, self.wizard.hp - (6.0 * self.dt))

        if self.wiz_casting:
            self.wiz_cast_remaining -= self.dt
            if self.wiz_cast_remaining <= 0:
                mult = self.dps_multiplier()
                base = 12.0 + self.wiz_damage_bonus
                if self.wiz_policy == "GREEDY":
                    base += 2.0
                dmg = max(0.0, (base * mult) - self.boss.armor)
                self.boss.hp = max(0.0, self.boss.hp - dmg)

                self.wiz_casting = False

                if self.wiz_policy == "GREEDY":
                    self.wiz_chain += 1
                    if self.wiz_chain >= 3:
                        self.wiz_chain = 0
                        self.wiz_backlash_remaining = 3.0
                        self.last_event = "Wizard over-aggro! Backlash ignites."
                    else:
                        self.last_event = f"Wizard nukes (-{int(dmg)}). Chain {self.wiz_chain}/3"
                else:
                    self.wiz_chain = max(0, self.wiz_chain - 1)
                    self.last_event = f"Wizard nukes (-{int(dmg)})."
            return

        cost = 4
        if self.wizard.mana < cost:
            self.wiz_chain = 0
            return

        if self.wiz_policy == "CAUTIOUS":
            if self.wizard.mana < 22:
                return
            if self.howl_active_remaining > 0 and random.random() < 0.75:
                return
            cast_time = 2.8
        elif self.wiz_policy == "NORMAL":
            if self.howl_active_remaining > 0 and random.random() < 0.5:
                return
            cast_time = 2.6
        else:
            cast_time = 2.2

        self.wizard.mana -= cost
        self.wiz_casting = True
        self.wiz_cast_remaining = cast_time

    def tick(self):
        if self.result is not None:
            return

        self.t += self.dt
        self.update_howl()

        # cooldowns
        self.tank_deflect_cd = max(0.0, self.tank_deflect_cd - self.dt)
        self.tank_taunt_cd = max(0.0, self.tank_taunt_cd - self.dt)
        self.rogue_burst_cd = max(0.0, self.rogue_burst_cd - self.dt)

        # Boss aftershock tracking
        self.rage_remaining = max(0.0, self.rage_remaining - self.dt)

        was_deflecting = self.tank_deflect_remaining > 0
        self.tank_taunt_remaining = max(0.0, self.tank_taunt_remaining - self.dt)
        self.tank_deflect_remaining = max(0.0, self.tank_deflect_remaining - self.dt)
        self.rogue_burst_remaining = max(0.0, self.rogue_burst_remaining - self.dt)

        # When Deflect ends, trigger a short "answer" window from the boss.
        if was_deflecting and self.tank_deflect_remaining <= 0 and self.pending_deflect_rage:
            self.pending_deflect_rage = False
            self.rage_remaining = 2.6
            self.last_event = f"{self.encounter.name} surges after Deflect!"

        # threat target
        target = self.tank
        if self.tank_taunt_remaining > 0:
            target = self.tank
        elif self.rogue_burst_remaining > 0:
            target = self.rogue

        dmg = self.tank_damage_in() * self.dt
        # deflect only protects tank when tank is hit
        if target is self.tank and self.tank_deflect_remaining > 0:
            dmg = 0.0

        # Non-tanks are much squishier when they pull aggro.
        if target is not self.tank:
            dmg *= 1.10

        dmg = max(0.0, dmg - target.armor * self.dt)
        target.hp = max(0.0, target.hp - dmg)

        self.cleric_tick()
        self.rogue_tick()
        self.wizard_tick()

        if not self.tank.is_alive():
            self.result = "LOSE"
            self.last_event = "The tank has fallen. Raid wipes."
            return

        if not self.boss.is_alive():
            self.result = "WIN"
            self.last_event = "Encounter cleared!"
            return


# -----------------------------
# UI Screens
# -----------------------------
class Screen(tk.Frame):
    def __init__(self, master, app):
        super().__init__(master)
        self.app = app

    def on_show(self):
        pass

class MainMenu(Screen):
    def __init__(self, master, app):
        super().__init__(master, app)
        self.configure(bg="#0f0f0f")

        tk.Label(self, text="RAIDBOUND (Prototype)", font=("Consolas", 28, "bold"),
                 fg="#dddddd", bg="#0f0f0f").pack(pady=40)
        tk.Label(self, text="Acts 1‚Äì3 ‚Äî Qeynos Hills ‚Üí Greater Faydark ‚Üí Najena", font=("Consolas", 14),
                 fg="#bbbbbb", bg="#0f0f0f").pack(pady=4)
        tk.Button(self, text="PLAY", font=("Consolas", 14, "bold"),
                  width=18, command=self.start_run).pack(pady=22)
        tk.Label(self, text="Manager mode: policies + role abilities.",
                 font=("Consolas", 11), fg="#888888", bg="#0f0f0f").pack(pady=10)

    def start_run(self):
        self.app.start_new_run()
        self.app.goto("MAP")


class MapScreen(Screen):
    """Slay-the-Spire style full map view.

    - Shows the entire act (15 depths) at once.
    - Click a highlighted reachable node to advance.
    - Elites are optional; routing lets you avoid them.
    """
    def __init__(self, master, app):
        super().__init__(master, app)
        self.configure(bg="#111111")

        self.header = tk.Label(self, text="", font=("Consolas", 16, "bold"),
                               fg="#dddddd", bg="#111111")
        self.header.pack(pady=10)
        
        self.subheader = tk.Label(self, text="", font=("Consolas", 12),
                               fg="#bbbbbb", bg="#111111")
        self.subheader.pack(pady=(0, 6))

        self.canvas = tk.Canvas(self, width=1280, height=540, bg="#111111", highlightthickness=0)
        self.canvas.pack()

        self.footer = tk.Label(self, text="", font=("Consolas", 11),
                               fg="#bbbbbb", bg="#111111")
        self.footer.pack(pady=8)

        tk.Button(self, text="ABANDON RUN", font=("Consolas", 11),
                  command=lambda: self.app.goto("MENU")).pack(pady=4)

        self.node_positions: dict[tuple[int, int], tuple[int, int]] = {}
        self.node_hitboxes: list[tuple[int, int, int, int, tuple[int, int]]] = []  # (x0,y0,x1,y1,key)

        self.canvas.bind("<Button-1>", self.on_click)

    def on_show(self):
        act = self.app.run_state.act
        biome = ACT_NAMES.get(act, f"Act {act}")
        self.header.configure(text=f"ACT {act} ‚Äî {biome}")
        self.subheader.configure(text="Choose your path")
        self.draw()

    def reachable_nodes(self) -> set[tuple[int, int]]:
        rs = self.app.run_state
        depth = rs.depth
        if depth < 1:
            depth = 1
        if rs.current_pos is None:
            # start of run: single starting node
            return {(1, 1)}

        cur = rs.current_pos
        nxt = self.app.map_edges.get(cur, [])
        return {k for k in nxt if k[0] == depth}

    def node_style(self, node: MapNode):
        # returns (outline, fill, icon)
        if node.kind == "ELITE":
            return "#ffcc66", "#1b1b1b", "‚ò†"
        if node.kind == "QUEST":
            return "#66ffcc", "#1b1b1b", "?"
        if node.kind == "BOSS":
            return "#ff6666", "#1b1b1b", "üëë"
        return "#55aaff", "#1b1b1b", "‚öî"

    def draw(self):
        rs = self.app.run_state
        depth = rs.depth
        act = rs.act
        biome = ACT_NAMES.get(act, f"Act {act}")
        self.header.configure(text=f"ACT {act} ‚Äî {biome}  |  Step {depth}/15  |  Run Time: {rs.run_seconds()}s")

        items = "  ‚Ä¢  ".join([i.name for i in rs.run_items]) if rs.run_items else "None"
        quest = rs.quest_item if rs.quest_item else "None"
        path = " ‚Üí ".join(rs.path_taken[-14:]) if rs.path_taken else "(start)"
        self.footer.configure(text=f"Run Items: {items}\nQuest Item: {quest}\nPath: {path}")

        self.canvas.delete("all")
        self.node_positions.clear()
        self.node_hitboxes.clear()

        # Map layout constants
        DEPTHS = 15
        LANES = 3

        # Left-to-right traversal across the wide window
        left_margin = 120
        right_margin = 1160

        # Three rows only (top/mid/bottom)
        top_y = 185
        bottom_y = 405

        x_spacing = (right_margin - left_margin) / (DEPTHS - 1)
        y_spacing = (bottom_y - top_y) / (LANES - 1)

        # Compute node positions (depth -> x, lane -> y)
        for layer in self.app.map_layers:
            for n in layer:
                x = int(left_margin + (n.depth - 1) * x_spacing)
                y = int(top_y + n.lane * y_spacing)
                self.node_positions[(n.depth, n.lane)] = (x, y)

        # Draw edges first
        for a, bs in self.app.map_edges.items():
            if a not in self.node_positions:
                continue
            x0, y0 = self.node_positions[a]
            for b in bs:
                if b not in self.node_positions:
                    continue
                x1, y1 = self.node_positions[b]
                self.canvas.create_line(x0, y0, x1, y1, fill="#333333", width=3)

        reachable = self.reachable_nodes()

        # Draw nodes
        for layer in self.app.map_layers:
            for n in layer:
                key = (n.depth, n.lane)
                x, y = self.node_positions[key]
                outline, fill, icon = self.node_style(n)

                r = 16
                w = 3
                if key in reachable:
                    r = 19
                    w = 4
                    # subtle glow
                    self.canvas.create_oval(x-(r+5), y-(r+5), x+(r+5), y+(r+5),
                                            outline=outline, width=2)

                # visited marker
                if rs.current_pos == key:
                    fill = "#222222"

                self.canvas.create_oval(x-r, y-r, x+r, y+r, fill=fill, outline=outline, width=w)
                self.canvas.create_text(x, y, text=icon, fill="#dddddd", font=("Consolas", 14, "bold"))

                # Hitbox for selection
                self.node_hitboxes.append((x-r, y-r, x+r, y+r, key))

        # Hint
        self.canvas.create_text(10, 520, anchor="nw", fill="#777777", font=("Consolas", 10),
                                text="Click a highlighted node to advance. Elites are optional.")

    def on_click(self, evt):
        x, y = evt.x, evt.y
        for x0, y0, x1, y1, key in self.node_hitboxes:
            if x0 <= x <= x1 and y0 <= y <= y1:
                if key in self.reachable_nodes():
                    self.choose(key)
                return

    def choose(self, key: tuple[int, int]):
        rs = self.app.run_state
        node = self.app.map_nodes[key]
        rs.current_pos = key
        rs.path_taken.append(node.kind)

        if node.kind == "QUEST":
            rs.quest_item = node.quest_item
            rs.depth = min(15, rs.depth + 1)
            self.draw()
            return

        self.app.start_node(node)

class CombatScreen(Screen):
    """
    Combat UI (manager mode):
      - Ability/policy boxes are placed next to the corresponding unit bars.
      - Each role uses a shared color for its box + related bars for quick scanning.
      - Keeps 1280x720 + tuned numbers + 12-step map.
    """
    def __init__(self, master, app):
        super().__init__(master, app)
        self.configure(bg="#111111")

        # Shared role colors (box background + related bar accent)
        self.TANK_BG    = "#1b2a3a"
        self.SUPPORT_BG = "#1f3a1f"   # forest green (readable with white text)
        self.MELEE_BG   = "#3a2418"
        self.RANGED_BG  = "#2a1f3a"

        self.TANK_BAR    = "#4fa3ff"
        self.SUPPORT_BAR = "#3f8f3f"
        self.MELEE_BAR   = "#d27a4a"
        self.RANGED_BAR  = "#bb77ff"
        self.MANA_BAR    = "#6aa9ff"

        # Top strip (status only)
        self.top = tk.Frame(self, bg="#0f0f0f")
        self.top.pack(side="top", fill="x")

        self.status = tk.Label(self.top, text="", bg="#0f0f0f", fg="#bbbbbb", font=("Consolas", 11))
        self.status.pack(side="right", padx=10, pady=6)

        # Combat canvas (bars + embedded control boxes)
        self.canvas = tk.Canvas(self, width=1280, height=680, bg="#111111", highlightthickness=0)
        self.canvas.pack(side="bottom", fill="both", expand=True)

        # --- Role boxes (created as frames, embedded into canvas) ---
        self.support_box = tk.LabelFrame(self, text="", bg=self.SUPPORT_BG, fg="#ffffff", bd=2)
        self.wizard_box  = tk.LabelFrame(self, text="", bg=self.RANGED_BG,  fg="#ffffff", bd=2)
        self.tank_box    = tk.LabelFrame(self, text="", bg=self.TANK_BG,    fg="#ffffff", bd=2)
        self.rogue_box   = tk.LabelFrame(self, text="", bg=self.MELEE_BG,   fg="#ffffff", bd=2)

        # Support policy buttons (stacked vertically)
        self.heal_buttons = {}
        for i, pol in enumerate(["CONSERVE", "BALANCED", "PANIC"]):
            b = tk.Button(self.support_box, text=pol, width=14, command=lambda p=pol: self.set_heal(p))
            b.grid(row=i, column=0, padx=6, pady=(4 if i == 0 else 3))
            self.heal_buttons[pol] = b

        # Wizard policy buttons (stacked vertically)
        self.wiz_buttons = {}
        for i, pol in enumerate(["CAUTIOUS", "NORMAL", "GREEDY"]):
            b = tk.Button(self.wizard_box, text=pol, width=14, command=lambda p=pol: self.set_wiz(p))
            b.grid(row=i, column=0, padx=6, pady=(4 if i == 0 else 3))
            self.wiz_buttons[pol] = b

        # Tank abilities: 1 active + 2 locked slots (stacked vertically)
        self.btn_deflect = tk.Button(self.tank_box, text="DEFLECT (T)", width=18, command=self.tank_deflect)
        self.btn_deflect.grid(row=0, column=0, padx=6, pady=(4, 3))

        self.btn_taunt = tk.Button(self.tank_box, text="TAUNT (Y)", width=18, command=self.tank_taunt)
        self.btn_taunt.grid(row=1, column=0, padx=6, pady=4)

        # Rogue abilities: 1 active + 2 locked slots (stacked vertically)
        self.btn_burst = tk.Button(self.rogue_box, text="BACKSTAB (F)", width=18, command=self.rogue_burst)
        self.btn_burst.grid(row=0, column=0, padx=6, pady=(4, 3))

        tk.Button(self.rogue_box, text="(locked)", width=18, state="disabled").grid(row=1, column=0, padx=6, pady=4)
        tk.Button(self.rogue_box, text="(locked)", width=18, state="disabled").grid(row=2, column=0, padx=6, pady=4)

        # Embed boxes next to bars (coordinates match bar layout in loop())
        # We'll create the windows once and move them if needed.
        # Embedded control boxes are positioned under their matching bars (Tank / Cleric / Rogue / Wizard).
        # These are re-created each redraw, but we also create initial windows so the layout is correct immediately.
        self._tank_win    = self.canvas.create_window(10, 134, anchor="nw", window=self.tank_box)
        self._support_win = self.canvas.create_window(325, 134, anchor="nw", window=self.support_box)
        self._rogue_win   = self.canvas.create_window(640, 134, anchor="nw", window=self.rogue_box)
        self._wizard_win  = self.canvas.create_window(955, 134, anchor="nw", window=self.wizard_box)

        self.paused = False

        # hotkeys
        self.bind_all("<space>", self.toggle_pause)
        self.bind_all("1", lambda e: self.set_heal("CONSERVE"))
        self.bind_all("2", lambda e: self.set_heal("BALANCED"))
        self.bind_all("3", lambda e: self.set_heal("PANIC"))
        self.bind_all("q", lambda e: self.set_wiz("CAUTIOUS"))
        self.bind_all("w", lambda e: self.set_wiz("NORMAL"))
        self.bind_all("e", lambda e: self.set_wiz("GREEDY"))
        self.bind_all("t", lambda e: self.tank_deflect())
        self.bind_all("T", lambda e: self.tank_deflect())
        self.bind_all("y", lambda e: self.tank_taunt())
        self.bind_all("Y", lambda e: self.tank_taunt())
        self.bind_all("f", lambda e: self.rogue_burst())
        self.bind_all("F", lambda e: self.rogue_burst())

    def on_show(self):
        self.paused = False
        self.refresh_btn_styles()
        self.loop()

    def toggle_pause(self, _evt=None):
        self.paused = not self.paused

    def set_heal(self, policy):
        fight = self.app.fight
        if fight is None:
            return
        fight.heal_policy = policy
        fight.last_event = f"Cleric policy set: {policy}"
        self.refresh_btn_styles()

    def set_wiz(self, policy):
        fight = self.app.fight
        if fight is None:
            return
        fight.wiz_policy = policy
        fight.last_event = f"Wizard policy set: {policy}"
        self.refresh_btn_styles()

    def tank_deflect(self):
        fight = self.app.fight
        if fight is None:
            return
        fight.tank_deflect()
        self.refresh_btn_styles()

    def tank_taunt(self):
        fight = self.app.fight
        if fight is None:
            return
        fight.tank_taunt()
        self.refresh_btn_styles()

    def rogue_burst(self):
        fight = self.app.fight
        if fight is None:
            return
        fight.rogue_backstab()
        self.refresh_btn_styles()

    def refresh_btn_styles(self):
        fight = self.app.fight
        if fight is None:
            return

        for pol, btn in self.heal_buttons.items():
            btn.configure(relief=("sunken" if fight.heal_policy == pol else "raised"))
        for pol, btn in self.wiz_buttons.items():
            btn.configure(relief=("sunken" if fight.wiz_policy == pol else "raised"))

        self.btn_deflect.configure(
            text=f"DEFLECT (T)\nCD {fight.tank_deflect_cd:0.1f}s" if fight.tank_deflect_cd > 0 else "DEFLECT (T)"
        )
        self.btn_taunt.configure(
            text=f"TAUNT (Y)\nCD {fight.tank_taunt_cd:0.1f}s" if fight.tank_taunt_cd > 0 else "TAUNT (Y)"
        )
        self.btn_burst.configure(
            text=f"BACKSTAB (F)\nCD {fight.rogue_burst_cd:0.1f}s" if fight.rogue_burst_cd > 0 else "BACKSTAB (F)"
        )

    def draw_bar(self, x, y, w, h, frac, label, fg, bg="#2a2a2a", text="#ffffff"):
        frac = clamp(frac, 0.0, 1.0)
        self.canvas.create_rectangle(x, y, x+w, y+h, fill=bg, outline="")
        self.canvas.create_rectangle(x, y, x+w*frac, y+h, fill=fg, outline="")
        self.canvas.create_text(x+6, y+h/2, anchor="w", fill=text, font=("Consolas", 11), text=label)

    def loop(self):
        fight = self.app.fight
        if fight is None:
            return

        if not self.paused and fight.result is None:
            fight.tick()

        if fight.result is not None:
            self.app.finish_node(fight.result)
            return

        self.refresh_btn_styles()

        self.canvas.delete("all")

        ph = fight.phase()
        howl = fight.howl_active_remaining > 0
        status = "PAUSED" if self.paused else "RUNNING"
        target = "TANK (taunt)" if fight.tank_taunt_remaining > 0 else ("ROGUE (aggro!)" if fight.rogue_burst_remaining > 0 else "TANK")
        self.status.configure(text=f"{status} | Phase: {ph}{' | DISRUPTION' if howl else ''} | Boss targeting: {target}")

        # Boss bar
        boss_frac = fight.boss.hp / fight.boss.max_hp
        self.draw_bar(10, 20, 1260, 26, boss_frac,
                      f"{fight.boss.name} {int(fight.boss.hp)}/{fight.boss.max_hp}",
                      fg="#ff5555", text="#ffffff")

        # Player bars: four role columns (Tank / Cleric / Rogue / Wizard)
        # This keeps each role's controls directly under its own bars (no interleaving).
        margin_x = 10
        gap = 10
        col_w = 305  # 4*305 + 3*10 = 1250, fits within 1260 usable width
        x_tank   = margin_x
        x_cleric = margin_x + (col_w + gap) * 1
        x_rogue  = margin_x + (col_w + gap) * 2
        x_wiz    = margin_x + (col_w + gap) * 3

        hp_y = 80
        hp_h = 22
        mana_y = hp_y + hp_h + 6
        mana_h = 16
        box_y = mana_y + mana_h + 10  # consistent anchor row for all control boxes

        # Tank
        self.draw_bar(x_tank, hp_y, col_w, hp_h, fight.tank.hp / fight.tank.max_hp,
                      f"Tank {int(fight.tank.hp)}/{fight.tank.max_hp}"
                      f"{' üõ°' if fight.tank_deflect_remaining > 0 else ''}",
                      fg=self.TANK_BAR, text="#ffffff")

        # Cleric
        self.draw_bar(x_cleric, hp_y, col_w, hp_h, fight.cleric.hp / fight.cleric.max_hp,
                      f"Cleric {int(fight.cleric.hp)}/{fight.cleric.max_hp}",
                      fg=self.SUPPORT_BAR, text="#ffffff")
        self.draw_bar(x_cleric, mana_y, col_w, mana_h, fight.cleric.mana / fight.cleric.max_mana,
                      f"MP {int(fight.cleric.mana)}/{fight.cleric.max_mana}"
                       f"{' ‚è≥' if fight.cleric_casting else ''}"
                       f"{'  CLUTCH‚úì' if fight.clutch_used else ''}",
                      fg=self.MANA_BAR, bg="#1f1f1f", text="#ffffff")

        # Rogue
        self.draw_bar(x_rogue, hp_y, col_w, hp_h, fight.rogue.hp / fight.rogue.max_hp,
                      f"Rogue {int(fight.rogue.hp)}/{fight.rogue.max_hp}"
                      f"{' ü©∏' if fight.rogue_burst_remaining > 0 else ''}",
                      fg=self.MELEE_BAR, text="#ffffff")

        # Wizard
        self.draw_bar(x_wiz, hp_y, col_w, hp_h, fight.wizard.hp / fight.wizard.max_hp,
                      f"Wizard {int(fight.wizard.hp)}/{fight.wizard.max_hp}",
                      fg=self.RANGED_BAR, text="#ffffff")

        backlash = f" üî•{fight.wiz_backlash_remaining:.1f}s" if fight.wiz_backlash_remaining > 0 else ""
        chain = f" C{fight.wiz_chain}/3" if fight.wiz_policy == "GREEDY" else ""
        self.draw_bar(x_wiz, mana_y, col_w, mana_h, fight.wizard.mana / fight.wizard.max_mana,
                      f"MP {int(fight.wizard.mana)}/{fight.wizard.max_mana}"
                       f"{' ‚è≥' if fight.wiz_casting else ''}{chain}{backlash}",
                      fg=self.MANA_BAR, bg="#1f1f1f", text="#ffffff")

        # Re-embed boxes after canvas redraw
        # Embedded control boxes are positioned under their matching bars (Tank / Cleric / Rogue / Wizard).
        # These are re-created each redraw, but we also create initial windows so the layout is correct immediately.
        self._tank_win    = self.canvas.create_window(10, 134, anchor="nw", window=self.tank_box)
        self._support_win = self.canvas.create_window(325, 134, anchor="nw", window=self.support_box)
        self._rogue_win   = self.canvas.create_window(640, 134, anchor="nw", window=self.rogue_box)
        self._wizard_win  = self.canvas.create_window(955, 134, anchor="nw", window=self.wizard_box)

        # Minimal helper text
        self.canvas.create_text(10, 640, anchor="nw", fill="#bbbbbb", font=("Consolas", 11),
                                text="Space: pause | Policies: 1/2/3 (cleric), q/w/e (wizard) | Abilities: T (deflect), Y (taunt), F (backstab)")
        self.canvas.create_text(10, 612, anchor="nw", fill="#dddddd", font=("Consolas", 12),
                                text=f"Event: {fight.last_event}")

        self.after(int(fight.dt * 1000), self.loop)

class EliteItemPick(Screen):
    def __init__(self, master, app):
        super().__init__(master, app)
        self.configure(bg="#111111")

        tk.Label(self, text="ELITE CLEARED", font=("Consolas", 18, "bold"),
                 fg="#ffcc66", bg="#111111").pack(pady=16)
        tk.Label(self, text="Pick 1 lesser run item (A / S / D).", font=("Consolas", 12),
                 fg="#bbbbbb", bg="#111111").pack(pady=4)

        self.card_frame = tk.Frame(self, bg="#111111")
        self.card_frame.pack(pady=20)
        self.options: list[RunItem] = []

        self.bind_all("a", lambda e: self.pick(0))
        self.bind_all("s", lambda e: self.pick(1))
        self.bind_all("d", lambda e: self.pick(2))
        self.bind_all("A", lambda e: self.pick(0))
        self.bind_all("S", lambda e: self.pick(1))
        self.bind_all("D", lambda e: self.pick(2))

    def on_show(self):
        self.options = pick_three(self.app.rng, LESSER_ITEMS)
        for w in self.card_frame.winfo_children():
            w.destroy()

        keys = ["A", "S", "D"]
        for i, item in enumerate(self.options):
            card = tk.Frame(self.card_frame, bg="#1b1b1b", highlightbackground="#444444", highlightthickness=2)
            card.grid(row=0, column=i, padx=16, ipadx=10, ipady=10)

            tk.Label(card, text=f"[{keys[i]}] {item.name}", font=("Consolas", 14, "bold"),
                     fg="#dddddd", bg="#1b1b1b").pack(pady=(6, 2))
            tk.Label(card, text=item.tag, font=("Consolas", 11, "bold"),
                     fg="#99c2ff", bg="#1b1b1b").pack(pady=(0, 8))
            tk.Label(card, text=item.desc, font=("Consolas", 11),
                     fg="#bbbbbb", bg="#1b1b1b", wraplength=240, justify="center").pack(pady=(0, 10))

            tk.Button(card, text="Pick", font=("Consolas", 11, "bold"),
                      command=lambda idx=i: self.pick(idx)).pack(pady=6)

    def pick(self, idx: int):
        self.app.run_state.run_items.append(self.options[idx])
        self.app.advance_depth()
        self.app.goto("MAP")


class BossItemPick(Screen):
    def __init__(self, master, app):
        super().__init__(master, app)
        self.configure(bg="#111111")

        tk.Label(self, text="üëë BOSS DEFEATED", font=("Consolas", 18, "bold"),
                 fg="#ff6666", bg="#111111").pack(pady=16)
        tk.Label(self, text="Pick 1 boss reward item (A / S / D).", font=("Consolas", 12),
                 fg="#bbbbbb", bg="#111111").pack(pady=4)

        self.card_frame = tk.Frame(self, bg="#111111")
        self.card_frame.pack(pady=20)
        self.options: list[RunItem] = []

        # Hotkeys
        self.bind_all("a", lambda e: self.pick(0))
        self.bind_all("s", lambda e: self.pick(1))
        self.bind_all("d", lambda e: self.pick(2))
        self.bind_all("A", lambda e: self.pick(0))
        self.bind_all("S", lambda e: self.pick(1))
        self.bind_all("D", lambda e: self.pick(2))

    def on_show(self):
        # Boss rewards are intentionally modest for MVP: choose from the same lesser pool.
        self.options = pick_three(self.app.rng, LESSER_ITEMS)

        for w in self.card_frame.winfo_children():
            w.destroy()

        keys = ["A", "S", "D"]
        for i, item in enumerate(self.options):
            card = tk.Frame(self.card_frame, bg="#1b1b1b",
                            highlightbackground="#444444", highlightthickness=2)
            card.grid(row=0, column=i, padx=16, ipadx=10, ipady=10)

            tk.Label(card, text=f"[{keys[i]}] {item.name}", font=("Consolas", 14, "bold"),
                     fg="#dddddd", bg="#1b1b1b").pack(pady=(6, 2))
            tk.Label(card, text=item.tag, font=("Consolas", 11, "bold"),
                     fg="#99c2ff", bg="#1b1b1b").pack(pady=(0, 8))
            tk.Label(card, text=item.desc, font=("Consolas", 11),
                     fg="#bbbbbb", bg="#1b1b1b", wraplength=240,
                     justify="center").pack(pady=(0, 10))

            tk.Button(card, text="Pick", font=("Consolas", 11, "bold"),
                      command=lambda idx=i: self.pick(idx)).pack(pady=6)

    def pick(self, idx: int):
        self.app.run_state.run_items.append(self.options[idx])

        # If the player has a quest item, they still get the delayed quest bonus next.
        if getattr(self.app, "post_boss_quest_pending", False):
            self.app.post_boss_quest_pending = False
            self.app.goto("QUEST_BONUS")
        else:
            self.app.goto("VICTORY")


class BonusQuestReward(Screen):
    def __init__(self, master, app):
        super().__init__(master, app)
        self.configure(bg="#111111")

        tk.Label(self, text="QUEST COMPLETE!", font=("Consolas", 18, "bold"),
                 fg="#66ff66", bg="#111111").pack(pady=16)
        self.subtitle = tk.Label(self, text="", font=("Consolas", 12),
                                 fg="#bbbbbb", bg="#111111")
        self.subtitle.pack(pady=4)

        self.card_frame = tk.Frame(self, bg="#111111")
        self.card_frame.pack(pady=20)

        self.options: list[RunItem] = []

        self.bind_all("a", lambda e: self.pick(0))
        self.bind_all("s", lambda e: self.pick(1))
        self.bind_all("d", lambda e: self.pick(2))

    def on_show(self):
        self.options = pick_three(self.app.rng, QUEST_BONUS_ITEMS)
        qi = self.app.run_state.quest_item
        self.subtitle.configure(text=f"You carried {qi} into the boss fight. Pick 1 bonus item (A/S/D).")

        for w in self.card_frame.winfo_children():
            w.destroy()

        keys = ["A", "S", "D"]
        for i, item in enumerate(self.options):
            card = tk.Frame(self.card_frame, bg="#1b1b1b", highlightbackground="#444444", highlightthickness=2)
            card.grid(row=0, column=i, padx=16, ipadx=10, ipady=10)

            tk.Label(card, text=f"[{keys[i]}] {item.name}", font=("Consolas", 14, "bold"),
                     fg="#dddddd", bg="#1b1b1b").pack(pady=(6, 2))
            tk.Label(card, text=item.tag, font=("Consolas", 11, "bold"),
                     fg="#99c2ff", bg="#1b1b1b").pack(pady=(0, 8))
            tk.Label(card, text=item.desc, font=("Consolas", 11),
                     fg="#bbbbbb", bg="#1b1b1b", wraplength=240, justify="center").pack(pady=(0, 10))

            tk.Button(card, text="Pick", font=("Consolas", 11, "bold"),
                      command=lambda idx=i: self.pick(idx)).pack(pady=6)

    def pick(self, idx: int):
        self.app.run_state.bonus_reward_item = self.options[idx]
        self.app.run_state.run_items.append(self.options[idx])
        self.app.goto("VICTORY")


class DeathScreen(Screen):
    def __init__(self, master, app):
        super().__init__(master, app)
        self.configure(bg="#0f0f0f")

        tk.Label(self, text="RAID WIPED", font=("Consolas", 26, "bold"),
                 fg="#ff6666", bg="#0f0f0f").pack(pady=30)

        self.stats = tk.Label(self, text="", font=("Consolas", 13), fg="#cccccc", bg="#0f0f0f")
        self.stats.pack(pady=10)

        tk.Button(self, text="PLAY AGAIN", font=("Consolas", 14, "bold"),
                  width=18, command=self.play_again).pack(pady=18)

        tk.Button(self, text="MAIN MENU", font=("Consolas", 12),
                  width=18, command=lambda: self.app.goto("MENU")).pack(pady=8)

    def on_show(self):
        rs = self.app.run_state
        self.stats.configure(text=f"Step reached: {rs.depth}/15\nRun Time: {rs.run_seconds()}s\nCause: Tank died (wipe condition)")

    def play_again(self):
        self.app.start_new_run()
        self.app.goto("MAP")


class VictoryScreen(Screen):
    def __init__(self, master, app):
        super().__init__(master, app)
        self.configure(bg="#0f0f0f")

        self.title_label = tk.Label(self, text="", font=("Consolas", 26, "bold"),
                                    fg="#66ff66", bg="#0f0f0f")
        self.title_label.pack(pady=30)

        self.subtitle = tk.Label(self, text="", font=("Consolas", 12),
                                 fg="#bbbbbb", bg="#0f0f0f")
        self.subtitle.pack(pady=2)

        self.stats = tk.Label(self, text="", font=("Consolas", 13), fg="#cccccc", bg="#0f0f0f")
        self.stats.pack(pady=10)

        self.items = tk.Label(self, text="", font=("Consolas", 11), fg="#999999", bg="#0f0f0f")
        self.items.pack(pady=10)

        self.continue_btn = tk.Button(self, text="", font=("Consolas", 14, "bold"),
                                      width=22, command=self.continue_act)
        self.continue_btn.pack(pady=16)
        self.continue_btn.pack_forget()

        self.play_again_btn = tk.Button(self, text="NEW RUN (ACT 1)", font=("Consolas", 12, "bold"),
                                        width=22, command=self.play_again)

        self.menu_btn = tk.Button(self, text="MAIN MENU", font=("Consolas", 12),
                                  width=22, command=lambda: self.app.goto("MENU"))

        # pack order (continue shown conditionally)
        self.play_again_btn.pack(pady=10)
        self.menu_btn.pack(pady=6)

    def on_show(self):
        act = self.app.run_state.act
        max_act = self.app.run_state.max_act
        biome = ACT_NAMES.get(act, f"Act {act}")

        if act < max_act:
            self.title_label.configure(text=f"ACT {act} CLEARED")
            self.subtitle.configure(text=f"Next: Act {act+1} ‚Äî {ACT_NAMES.get(act+1, '???')}")
            self.continue_btn.configure(text=f"CONTINUE TO ACT {act+1}")
            if not self.continue_btn.winfo_ismapped():
                self.continue_btn.pack(pady=16, before=self.play_again_btn)
        else:
            self.title_label.configure(text="RUN COMPLETE")
            self.subtitle.configure(text="You cleared all available acts!")
            if self.continue_btn.winfo_ismapped():
                self.continue_btn.pack_forget()

        rs = self.app.run_state
        self.stats.configure(text=f"Total Run Time: {rs.run_seconds()}s")
        if rs.run_items:
            self.items.configure(text="Items carried:\n- " + "\n- ".join([i.name for i in rs.run_items]))
        else:
            self.items.configure(text="Items carried: (none)")

    def continue_act(self):
        self.app.continue_to_next_act()

    def play_again(self):
        self.app.start_new_run()
        self.app.goto("MAP")


# -----------------------------
# App Controller
# -----------------------------

class RaidboundApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("1280x720")
        self.resizable(False, False)

        self.rng = random.Random()
        self.rng.seed(time.time())

        # Run/act state
        self.run_state = RunState()

        # Act-scoped resources
        self.encounters = make_encounters(self.run_state.act)
        self.quest_items = QUEST_ITEMS_BY_ACT.get(self.run_state.act, QUEST_ITEMS_BY_ACT[1])
        self.refresh_act_resources()

        # Map data
        self.map_layers = []
        self.map_edges = {}
        self.map_nodes = {}

        # Combat
        self.fight = None
        self.current_node = None
        self.post_boss_quest_pending = False

        # Root container
        self.container = tk.Frame(self, bg="#000000")
        self.container.pack(fill="both", expand=True)

        # Screens
        self.screens = {}
        for name, cls in [
            ("MENU", MainMenu),
            ("MAP", MapScreen),
            ("COMBAT", CombatScreen),
            ("ELITE_PICK", EliteItemPick),
            ("BOSS_PICK", BossItemPick),
            ("QUEST_BONUS", BonusQuestReward),
            ("DEATH", DeathScreen),
            ("VICTORY", VictoryScreen),
        ]:
            frame = cls(self.container, self)
            frame.place(x=0, y=0, relwidth=1, relheight=1)
            self.screens[name] = frame

        self.goto("MENU")

    def refresh_act_resources(self):
        """Refresh act-dependent resources such as encounters, quest items, and window title."""
        self.encounters = make_encounters(self.run_state.act)
        self.quest_items = QUEST_ITEMS_BY_ACT.get(self.run_state.act, QUEST_ITEMS_BY_ACT[1])
        biome = ACT_NAMES.get(self.run_state.act, f"Act {self.run_state.act}")
        self.title(f"Raidbound ‚Äî Act {self.run_state.act}: {biome}")

    def start_new_run(self):
        """Start a fresh campaign from Act 1, wiping run items and resetting progress."""
        self.run_state.reset_campaign()
        self.refresh_act_resources()
        self.start_act()
        self.goto("MAP")

    def start_act(self):
        """Start (or restart) the current act map without wiping accumulated run items."""
        self.run_state.reset_act()
        self.map_layers, self.map_edges = generate_map(self.rng, self.encounters, self.quest_items)
        self.map_nodes = {(n.depth, n.lane): n for layer in self.map_layers for n in layer}
        self.fight = None
        self.current_node = None
        self.post_boss_quest_pending = False

    def continue_to_next_act(self):
        """Advance to the next act, preserving run items."""
        if self.run_state.act >= self.run_state.max_act:
            self.goto("MENU")
            return
        self.run_state.act += 1
        self.refresh_act_resources()
        self.start_act()
        self.goto("MAP")

    def goto(self, name: str):
        frame = self.screens[name]
        frame.tkraise()
        frame.on_show()

    def start_node(self, node: MapNode):
        self.current_node = node
        self.fight = RaidFight(self.run_state, node)
        self.goto("COMBAT")

    def advance_depth(self):
        self.run_state.depth += 1
        if self.run_state.depth > 15:
            self.run_state.depth = 15

    def finish_node(self, result: str):
        if result == "LOSE":
            self.goto("DEATH")
            return

        kind = self.current_node.kind

        if kind == "BOSS":
            # Always grant a boss reward item.
            # If the player carried a quest item, they get the delayed quest bonus after the boss reward.
            self.post_boss_quest_pending = bool(self.run_state.quest_item)
            self.goto("BOSS_PICK")
            return

        if kind == "ELITE":
            self.goto("ELITE_PICK")
            return

        # SKIRMISH: no loot
        self.advance_depth()
        self.goto("MAP")


if __name__ == "__main__":
    RaidboundApp().mainloop()
